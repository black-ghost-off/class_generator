import yaml
import sys
import re
import os

dtypes_names = {
    "yaml": [
        "bool", "char", "int8", "uint8", "int16", "uint16", "int32", "uint32",
        "int64", "uint64", "float", "float16", "float32", "float64", "float128", "void"
    ],
    "python": [
        "np.bool_", "np.char", "np.int8", "np.uint8", "np.int16", "np.uint16", "np.int32", "np.uint32", 
        "np.int64", "np.uint64", "np.float32", "np.float16", "np.float32", "np.float64", "np.float128", None
    ],
    "c": [
        "bool", "char", "int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", 
        "int64_t", "uint64_t", "float", None, "float", "double", "long double", "void"
    ],
    "cpp": [
        "bool", "char", "int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", 
        "int64_t", "uint64_t", "float", None, "float", "double", "long double", "void"
    ],
    "go":[
        "bool", "char", "int8", "uint8", "int16", "uint16", "int32", "uint32",
        "int64", "uint64", "float32", None, "float32", "float64", None, None
    ]
}

template_name = {
    "comment_symbols": {
        "python": "# ",
        "c": "// ",
        "cpp": "// ",
        "go": "// "
    },
    "header_templates": {
        "python": "# PYTHON generated by class generator: {data_gen}",
        "c": "// C generated by class generator: {data_gen}\n#ifndef {header_file}\n#define {header_file}",
        "cpp": "// CPP generated by class generator: {data_gen}\n#ifndef {header_file}\n#define {header_file}",
        "go": "// GO generated by class generator: {data_gen} \n\npackage {file_name}"
    },
    "include_statements": {
        "python": ["import numpy as np"],
        "c": ["#include <stdio.h>"],
        "cpp": ["#include <iostream>"],
        "go": ["package main"]
    },
    "define_statements": {
        "python": "{define_name} = {define_value}",
        "c": "#define {define_name} {define_value}",
        "cpp": "#define {define_name} {define_value}",
        "go": "const {define_name} = {define_value}"
    },
    "enum_element_template":{
        "python": ["    {enum_name} = {enum_value}", "    {enum_name} = {enum_value}"],
        "c": ["    {enum_name} = {enum_value}", "    {enum_name}"],
        "cpp": ["    {enum_name} = {enum_value}", "    {enum_name}"],
        "go": ["    {enum_name} = {enum_value}", "    {enum_name} = {enum_value}"]
    },
    "enums_templates": {
        "python": "class {enum_name}: \n{enums}",
        "c": "typedef enum {enum_name} {{\n{enums}}} {enum_name};",
        "cpp": "enum class {enum_name} {{\n{enums}}};",
        "go": "type {enum_name} int\nconst (\n{enums})"
    },
    "class_field_template":{
        "python": ["    {field_name} = None", "    {field_name} = None"],
        "c": ["    {field_datatype} {field_name}", "    {field_datatype} {field_name}[{field_size}]"],
        "cpp": ["    {field_datatype} {field_name}", "    {field_datatype} {field_name}[{field_size}]"],
        "go": ["    {field_name} {field_datatype}", "    {field_name} [{field_size}]{field_datatype}"]
    },
    "struct_filed_template":{
        "python": ['    ("{field_name}", {field_datatype}),', '    ("{field_name}", {field_datatype}, ({field_size},)),'],
        "c": ['    {field_datatype} {field_name};', '    {field_datatype} {field_name}[{field_size}];'],
        "cpp": ['        {field_datatype} {field_name};', '        {field_datatype} {field_name}[{field_size}];'],
        "go": ['    {field_name} {field_datatype}', '    {field_name} [{field_size}]{field_datatype}']
    },
    "class_field_prefix": {
        "python": "    ",
        "c": "",
        "cpp": "",
        "go": ""
    },
    "gen_class_functions": {
        "python": "    def {function_name}({params}):\n        pass\n",
        "c": "{return_type} {function_name}({params});",
        "cpp": "    {return_type} {function_name}({params});",
        "go": "func {function_name}({params}) {return_type} {{\n\n}}"
    },
    "class_function_name_prefix": {
        "python": "",
        "c": "{class_name}_",
        "cpp": "",
        "go": "{class_name}_"
    },        
    "gen_class": {
        "python": "class {class_name}: \n    structure = np.dtype([\n{fields}    ])\n{functions}\n",
        "c": "struct {class_name} {{\n{fields}\n}};\n{functions}",
        "cpp": "class {class_name} {{\nprivate:\n    #pragma pack(push, 1)\n    struct Struct{{\n{fields}    }};\n    #pragma pack(pop)\n\npublic:\n    {class_name}();\n    ~{class_name}();\n\n{functions}\n}};",
        "go": "type {class_name} struct {{\n{fields}\n}}\n\n{functions}"
    },
    "gen_params_function": {
        "python": "{param_name}",
        "c": "{param_type} {param_name}",
        "cpp": "{param_type} {param_name}",
        "go": "{param_name} {param_type}"
    },
    "gen_functions": {
        "python": "def {function_name}({params}):\n    pass\n",
        "c": "{return_type} {function_name}({params});",
        "cpp": "    {return_type} {function_name}({params});",
        "go": "func {function_name}({params}) {return_type} {{\n\n}}"
    },
    "gen_end": {
        "python": "",  
        "c": "#endif",
        "cpp": "#endif",
        "go": ""
    }
}

def replace_letters_with_underscore(text):
    return re.sub(r'[^a-zA-Z]', '_', text)

def yaml_name_to_lang(yaml_name, lang):
    index = dtypes_names["yaml"].index(yaml_name)
    return dtypes_names[lang][index]

def add_new_datatype(datatype, lang=None):
    if lang is None:
        for key in dtypes_names:
            dtypes_names[key].append(datatype)
    else:
        dtypes_names[lang].append(datatype)

def gen_comments(file_string, lang):
    file_string = file_string.replace("->", template_name["comment_symbols"][lang])
    return file_string

def gen_header(file_string, lang, header_file):
    # Extract the last part of the header file path
    file_name = os.path.basename(header_file)
    
    # Generate the header content
    header_content = template_name["header_templates"][lang].format(data_gen="class generator", header_file=replace_letters_with_underscore(file_name).upper(), file_name=file_name)
    
    # Generate include statements
    include_statements = "\n".join(template_name["include_statements"][lang])
    
    # Replace placeholders in the file string
    file_string = file_string.replace("{header}", header_content)
    file_string = file_string.replace("{includes}", include_statements)
    
    return file_string

def gen_user_header(file_string, lang, file_string_pre):
    user_header = re.search((f'{template_name["comment_symbols"][lang]}USER_CODE_BEGIN header\n(.*?)\n{template_name["comment_symbols"][lang]}USER_CODE_END'), file_string_pre)
    if user_header is not None:
        user_header = user_header.group(1)
    else:
        user_header = ""
    file_string = file_string.replace("{user_header}", user_header)
    return file_string

def gen_includes(file_string, lang):
    include_statements = "\n".join(template_name["include_statements"][lang])
    file_string = file_string.replace("{includes}", include_statements)
    return file_string

def gen_user_includes(file_string, lang, file_string_pre):
    user_includes = re.search((f'{template_name["comment_symbols"][lang]}USER_CODE_BEGIN includes\n(.*?)\n{template_name["comment_symbols"][lang]}USER_CODE_END'), file_string_pre)
    if user_includes is not None:
        user_includes = user_includes.group(1)
    else:
        user_includes = ""
    file_string = file_string.replace("{user_includes}", user_includes)
    return file_string

def gen_defines(file_string, lang, defines):
    defines_list = ""
    for i, define in enumerate(defines):
        define_name = define["name"]
        define_value = define["value"]
        define_string = template_name["define_statements"][lang].format(define_name=define_name, define_value=define_value)
        if i == len(defines) - 1:
            pass
        else:
            define_string += "\n"

        defines_list += define_string   
    file_string = file_string.replace("{defines}", defines_list)
    return file_string

def gen_user_defines(file_string, lang, file_string_pre):
    user_defines = re.search((f'{template_name["comment_symbols"][lang]}USER_CODE_BEGIN defines\n(.*?)\n{template_name["comment_symbols"][lang]}USER_CODE_END'), file_string_pre)
    if user_defines is not None:
        user_defines = user_defines.group(1)
    else:
        user_defines = ""
    file_string = file_string.replace("{user_defines}", user_defines)
    return file_string

def gen_enums(file_string, lang, enums):
    enums_list = ""
    for i, enum in enumerate(enums):
        enum_name = enum["name"]
        enum_values_string = ""
        for enum_element in enum['values']:
            enum_element_name = enum_element['name']
            enum_element_value = enum_element.get('value', None)
            enum_element_count = 0
            if enum_element_value is not None:
                enum_element_string = template_name["enum_element_template"][lang][0].format(enum_name=enum_element_name, enum_value=enum_element_value)
                enum_element_count = enum_element_value
            else:
                enum_element_count += 1
                enum_element_string = template_name["enum_element_template"][lang][1].format(enum_name=enum_element_name, enum_value=enum_element_count)
            enum_element_string += "\n"
            enum_values_string += enum_element_string
        enum_string = template_name["enums_templates"][lang].format(enum_name=enum_name, enums=enum_values_string)
        enums_list += enum_string
        if i == len(enums) - 1:
            pass
        else:
            enums_list += "\n\n"
    file_string = file_string.replace("{enums}", enums_list)
        
    return file_string

def gen_user_enums(file_string, lang, file_string_pre):
    user_enums = re.search((f'{template_name["comment_symbols"][lang]}USER_CODE_BEGIN enums\n(.*?)\n{template_name["comment_symbols"][lang]}USER_CODE_END'), file_string_pre)
    if user_enums is not None:
        user_enums = user_enums.group(1)
    else:
        user_enums = ""
    file_string = file_string.replace("{user_enums}", user_enums)

    return file_string

def gen_class_functions_list(lang, functions, class_name):
    functions_list = ""
    for i, function in enumerate(functions):
        function_name = function["name"]
        return_type = yaml_name_to_lang(function["return_type"], lang)
        if return_type is None:
            return_type = ""
        params = function["params"]
        params_text = ""
        for bi, param in enumerate(params):
            for param_name, param_info in param.items():
                param_type = yaml_name_to_lang(param_info["type"], lang)
                if param_type is None:
                    print(f"WARNING: Unknown datatype: {param_info['type']} for parameter: {param_name} in language: {lang}, replace with int32")
                    param_type = yaml_name_to_lang("int32", lang)

                params_text += template_name["gen_params_function"][lang].format(param_name=param_name, param_type=param_type) 
                if bi == len(params) - 1:
                    pass
                else:
                    params_text += ", "

        function_text = template_name["gen_class_functions"][lang].format(function_name=(template_name["class_function_name_prefix"][lang] + function_name).format(class_name=class_name), return_type=return_type, params=params_text)
        if i == len(functions) - 1:
            pass
        else:
            function_text += "\n"

        functions_list += function_text

    # functions_list += "\

    return functions_list

def gen_classes(file_string, lang, classes):
    classes_list = ""
    for i, class_ in enumerate(classes):
        class_name = class_["name"]
        fields = class_["fields"]
        functions_text = gen_class_functions_list(lang, class_["functions"], class_name)
        fields_list = ""

        for field in class_.get('fields', []):
            for field_name, field_info in field.items():
                field_type = yaml_name_to_lang(field_info['type'], lang)
                field_size = field_info.get('size', None)
                if field_size is not None:
                    fields_list += template_name["class_field_prefix"][lang] + template_name["struct_filed_template"][lang][1].format(field_name=field_name, field_datatype=field_type, field_size=field_size)
                else:
                    fields_list += template_name["class_field_prefix"][lang] + template_name["struct_filed_template"][lang][0].format(field_name=field_name, field_datatype=field_type)
                fields_list += "\n"
                
        class_string = template_name["gen_class"][lang].format(class_name=class_name, fields=fields_list, functions=functions_text, class_field="")
        classes_list += class_string
        if i == len(classes) - 1:
            pass
        else:
            classes_list += "\n"
    file_string = file_string.replace("{classes}", classes_list)
    return file_string

def gen_user_classes(file_string, lang, file_string_pre):
    user_classes = re.search((f'{template_name["comment_symbols"][lang]}USER_CODE_BEGIN classes\n(.*?)\n{template_name["comment_symbols"][lang]}USER_CODE_END'), file_string_pre)
    if user_classes is not None:
        user_classes = user_classes.group(1)
    else:
        user_classes = ""
    file_string = file_string.replace("{user_classes}", user_classes)
    return file_string

def gen_functions(file_string, lang, functions):
    functions_list = ""
    for i, function in enumerate(functions):
        function_name = function["name"]
        return_type = yaml_name_to_lang(function["return_type"], lang)
        if return_type is None:
            return_type = ""
        params = function["params"]
        params_text = ""
        for bi, param in enumerate(params):
            for param_name, param_info in param.items():
                param_type = yaml_name_to_lang(param_info["type"], lang)
                if param_type is None:
                    print(f"WARNING: Unknown datatype: {param_info['type']} for parameter: {param_name} in language: {lang}, replace with int32")
                    param_type = yaml_name_to_lang("int32", lang)

                params_text += template_name["gen_params_function"][lang].format(param_name=param_name, param_type=param_type) 
                if bi == len(params) - 1:
                    pass
                else:
                    params_text += ", "

        function_text = template_name["gen_functions"][lang].format(function_name=function_name, return_type=return_type, params=params_text)
        if i == len(functions) - 1:
            pass
        else:
            function_text = function_text + "\n"
        functions_list += function_text
    file_string = file_string.replace("{functions}", functions_list)
    return file_string

def gen_user_functions(file, lang, string_pre):
    user_functions = re.search((f'{template_name["comment_symbols"][lang]}USER_CODE_BEGIN functions\n(.*?)\n{template_name["comment_symbols"][lang]}USER_CODE_END'), string_pre)
    if user_functions is not None:
        user_functions = user_functions.group(1)
    else:
        user_functions = ""
    file = file.replace("{user_functions}", user_functions)
    return file

def gen(yaml_file, header_file, lang):
    with open(yaml_file, 'r') as file:
        data = yaml.safe_load(file)
    
    classes = data.get('classes', [])
    functions = data.get('functions', [])
    defines = data.get('defines', [])
    enums = data.get('enums', None)
    
    save = None
    try:
        with open(header_file, 'r') as file:
            save = file.read()
    except:
        save = ""
            
    with open("./file_structure.txt", 'r') as file_structure:
        file_structure_string = file_structure.read()
        
        file_structure_string = gen_user_header(file_structure_string, lang, save)
        file_structure_string = gen_user_defines(file_structure_string, lang, save)
        file_structure_string = gen_user_includes(file_structure_string, lang, save)
        file_structure_string = gen_user_enums(file_structure_string, lang, save)
        file_structure_string = gen_user_classes(file_structure_string, lang, save)    
        file_structure_string = gen_user_functions(file_structure_string, lang, save)

        file_structure_string = gen_comments(file_structure_string, lang)
        file_structure_string = gen_header(file_structure_string, lang, header_file)
        file_structure_string = gen_includes(file_structure_string, lang)
        file_structure_string = gen_defines(file_structure_string, lang, defines)
        file_structure_string = gen_enums(file_structure_string, lang, enums)
        file_structure_string = gen_classes(file_structure_string, lang, classes)
        file_structure_string = gen_functions(file_structure_string, lang, functions)

    with open(header_file, 'w') as file:
        file.write(file_structure_string) 